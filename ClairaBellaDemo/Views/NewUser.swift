//
//  NewUser.swift
//
//  Created on 04/05/17.
//
//  Generated by PaintCode Plugin for Sketch
//  http://www.paintcodeapp.com/sketch
//

import UIKit



class NewUser: NSObject {
    
    
    //MARK: - Canvas Drawings
    
    /// Loading Screens
    
    class func drawNewUsers(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 320, height: 570), resizing: ResizingBehavior = .aspectFit) {
        /// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        let baseTransform = context.userSpaceToDeviceSpaceTransform.inverted()
        
        /// Resize to Target Frame
        context.saveGState()
        let resizedFrame = resizing.apply(rect: CGRect(x: 0, y: 0, width: 320, height: 570), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 320, y: resizedFrame.height / 570)
        
        /// Background Color
        UIColor.white.setFill()
        context.fill(context.boundingBoxOfClipPath)
        
        /// Base
        let base2 = UIBezierPath()
        base2.move(to: CGPoint(x: 0, y: 4))
        base2.addCurve(to: CGPoint(x: 4, y: 0), controlPoint1: CGPoint(x: 0, y: 1.79), controlPoint2: CGPoint(x: 1.8, y: 0))
        base2.addLine(to: CGPoint(x: 316, y: 0))
        base2.addCurve(to: CGPoint(x: 320, y: 4), controlPoint1: CGPoint(x: 318.21, y: 0), controlPoint2: CGPoint(x: 320, y: 1.8))
        base2.addLine(to: CGPoint(x: 320, y: 572))
        base2.addLine(to: CGPoint(x: 0, y: 572))
        base2.addLine(to: CGPoint(x: 0, y: 4))
        base2.close()
        base2.move(to: CGPoint(x: 0, y: 4))
        context.saveGState()
        context.translateBy(x: 0, y: -2)
        base2.usesEvenOddFillRule = true
        UIColor(hue: 0.855, saturation: 0.359, brightness: 0.926, alpha: 1).setFill()
        base2.fill()
        context.restoreGState()
        /// Oval
        let oval = UIBezierPath(ovalIn: CGRect(x: 0, y: 0, width: 323, height: 323))
        context.saveGState()
        context.translateBy(x: -1, y: 49)
        context.saveGState()
        oval.addClip()
        context.translateBy(x: 166.83, y: 142.77)
        context.drawRadialGradient(CGGradient(colorsSpace: nil, colors: [
                    UIColor.white.cgColor,
                    UIColor(hue: 0.855, saturation: 0.356, brightness: 0.925, alpha: 1).cgColor,
                ] as CFArray, locations: [0, 1])!,
            startCenter: CGPoint.zero, startRadius: 0,
            endCenter: CGPoint.zero, endRadius: 107.87,
            options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
        context.restoreGState()
        context.restoreGState()
        /// PLACEHOLDER - Character
        // Warning: Image layers are not supported.
        /// Welcome to
        let welcomeTo = NSMutableAttributedString(string: "Welcome to")
        welcomeTo.addAttribute(NSFontAttributeName, value: UIFont(name: "Arial", size: 17)!, range: NSRange(location: 0, length: welcomeTo.length))
        welcomeTo.addAttribute(NSForegroundColorAttributeName, value: UIColor.white, range: NSRange(location: 0, length: welcomeTo.length))
        welcomeTo.addAttribute(NSKernAttributeName, value: -0.29, range: NSRange(location: 0, length: welcomeTo.length))
        do {
            let paragraphStyle = NSMutableParagraphStyle()
            paragraphStyle.alignment = .center
            welcomeTo.addAttribute(NSParagraphStyleAttributeName, value: paragraphStyle, range: NSRange(location: 0, length: welcomeTo.length))
        }
        do {
            let shadow = NSShadow()
            shadow.shadowColor = UIColor(hue: 0.887, saturation: 0.929, brightness: 0.878, alpha: 0.7)
            let baseZero = context.convertToDeviceSpace(CGPoint.zero).applying(baseTransform)
            let baseOne = context.convertToDeviceSpace(CGPoint(x: 1, y: 1)).applying(baseTransform)
            let baseOffset = context.convertToDeviceSpace(CGPoint(x: -1, y: 0)).applying(baseTransform)
            shadow.shadowOffset = CGSize(width: baseOffset.x - baseZero.x, height: baseOffset.y - baseZero.y)
            shadow.shadowBlurRadius = 2 * min(baseOne.x - baseZero.x, baseOne.y - baseZero.y)
            welcomeTo.addAttribute(NSShadowAttributeName, value: shadow, range: NSRange(location: 0, length: welcomeTo.length))
        }
        context.saveGState()
        welcomeTo.draw(in: CGRect(x: 20, y: 257, width: 280, height: 22))
        context.restoreGState()
        /// Create unique charac
        let createUniqueCharac = NSMutableAttributedString(string: "Create unique characters to\nshare with Family & Friends")
        createUniqueCharac.addAttribute(NSFontAttributeName, value: UIFont(name: "Arial", size: 16)!, range: NSRange(location: 0, length: createUniqueCharac.length))
        createUniqueCharac.addAttribute(NSForegroundColorAttributeName, value: UIColor.white, range: NSRange(location: 0, length: createUniqueCharac.length))
        do {
            let paragraphStyle = NSMutableParagraphStyle()
            paragraphStyle.alignment = .center
            paragraphStyle.maximumLineHeight = 20
            paragraphStyle.minimumLineHeight = 20
            createUniqueCharac.addAttribute(NSParagraphStyleAttributeName, value: paragraphStyle, range: NSRange(location: 0, length: createUniqueCharac.length))
        }
        context.saveGState()
        createUniqueCharac.draw(in: CGRect(x: 18, y: 337, width: 282, height: 44))
        context.restoreGState()
        /// CTA
        do {
            context.saveGState()
            context.translateBy(x: 0, y: 395)
            
            /// Rectangle 14
           // let rectangle14 = UIBezierPath(roundedRect: CGRect(x: 0, y: 0, width: 269, height: 48), cornerRadius: 32)
           // context.saveGState()
           // context.translateBy(x: 26, y: 0)
           // UIColor.white.setFill()
           // rectangle14.fill()
           // context.restoreGState()
            
            /// Let’s Start
           // let letsStart = NSMutableAttributedString(string: "Let’s Start")
            //letsStart.addAttribute(NSFontAttributeName, value: UIFont(name: "Arial", size: 18)!, range: NSRange(location: 0, length: letsStart.length))
           // letsStart.addAttribute(NSForegroundColorAttributeName, value: UIColor(hue: 0.887, saturation: 0.929, brightness: 0.878, alpha: 1), range: NSRange(location: 0, length: letsStart.length))
            do {
                let paragraphStyle = NSMutableParagraphStyle()
                paragraphStyle.alignment = .center
              //  letsStart.addAttribute(NSParagraphStyleAttributeName, value: paragraphStyle, range: NSRange(location: 0, length: letsStart.length))
            }
            context.saveGState()
          //  letsStart.draw(in: CGRect(x: 0, y: 14, width: 320, height: 24))
            context.restoreGState()
            
            context.restoreGState()
        }
        /// ClaireaBella
        let claireaBella = NSMutableAttributedString(string: "ClaireaBella")
        claireaBella.addAttribute(NSFontAttributeName, value: UIFont(name: "Arial", size: 42)!, range: NSRange(location: 0, length: claireaBella.length))
        claireaBella.addAttribute(NSForegroundColorAttributeName, value: UIColor.white, range: NSRange(location: 0, length: claireaBella.length))
        claireaBella.addAttribute(NSKernAttributeName, value: -0.38, range: NSRange(location: 0, length: 11))
        claireaBella.addAttribute(NSKernAttributeName, value: -0.5, range: NSRange(location: 11, length: 1))
        do {
            let paragraphStyle = NSMutableParagraphStyle()
            paragraphStyle.alignment = .center
            claireaBella.addAttribute(NSParagraphStyleAttributeName, value: paragraphStyle, range: NSRange(location: 0, length: claireaBella.length))
        }
        do {
            let shadow = NSShadow()
            shadow.shadowColor = UIColor(hue: 0.887, saturation: 0.929, brightness: 0.878, alpha: 0.7)
            let baseZero = context.convertToDeviceSpace(CGPoint.zero).applying(baseTransform)
            let baseOne = context.convertToDeviceSpace(CGPoint(x: 1, y: 1)).applying(baseTransform)
            let baseOffset = context.convertToDeviceSpace(CGPoint(x: -1, y: 0)).applying(baseTransform)
            shadow.shadowOffset = CGSize(width: baseOffset.x - baseZero.x, height: baseOffset.y - baseZero.y)
            shadow.shadowBlurRadius = 2 * min(baseOne.x - baseZero.x, baseOne.y - baseZero.y)
            claireaBella.addAttribute(NSShadowAttributeName, value: shadow, range: NSRange(location: 0, length: claireaBella.length))
        }
        context.saveGState()
        claireaBella.draw(in: CGRect(x: 17, y: 269, width: 280, height: 55))
        context.restoreGState()
        
        context.restoreGState()
    }
    
    
    //MARK: - Canvas Images
    
    /// Loading Screens
    
    class func imageOfNewUsers() -> UIImage {
        struct LocalCache {
            static var image: UIImage!
        }
        if LocalCache.image != nil {
            return LocalCache.image
        }
        var image: UIImage
        
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 320, height: 570), false, 0)
        NewUser.drawNewUsers()
        image = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()
        
        LocalCache.image = image
        return image
    }
    
    
    //MARK: - Resizing Behavior
    
    enum ResizingBehavior {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.
        
        func apply(rect: CGRect, target: CGRect) -> CGRect {
            if rect == target || target == CGRect.zero {
                return rect
            }
            
            var scales = CGSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)
            
            switch self {
                case .aspectFit:
                    scales.width = min(scales.width, scales.height)
                    scales.height = scales.width
                case .aspectFill:
                    scales.width = max(scales.width, scales.height)
                    scales.height = scales.width
                case .stretch:
                    break
                case .center:
                    scales.width = 1
                    scales.height = 1
            }
            
            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }
    
    
}
